<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8" />
    <title>Kray-zee</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
  <script src="https://rawgithub.com/mrdoob/three.js/master/build/three.js"></script> <!-- Get the latest version of the Three.js library. -->
    <script>
        // Create a Three.js scene object.
        var scene = new THREE.Scene();
        // Define the perspective camera's attributes.
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); 


        var renderer = window.WebGLRenderingContext ? new THREE.WebGLRenderer() : new THREE.CanvasRenderer(); // Fallback to canvas renderer, if necessary.
        
        renderer.setSize(window.innerWidth, window.innerHeight); // Set the size of the WebGL viewport.
        
        document.body.appendChild(renderer.domElement); // Append the WebGL viewport to the DOM.

        var geometry = new THREE.CubeGeometry(5, 60, 5);
        var material = new THREE.MeshBasicMaterial({ color: 0x00d8ff });
        
        var barsLeft = [];

        for (var i = 0; i <= 15; ++i) {
            barsLeft[i] = new THREE.Mesh(geometry, material);

            barsLeft[i].position.z = -i*20;
            barsLeft[i].position.x = -50;
            
            scene.add(barsLeft[i]);
        }
        
        var barsRight = [];

        for (var i = 0; i <= 15; ++i) {
            barsRight[i] = new THREE.Mesh(geometry, material);

            barsRight[i].position.z = -i*20;
            barsRight[i].position.x = 50;
            
            scene.add(barsRight[i]);
        }
        
        
        camera.position.z = 50; // Move the camera away from the origin, down the positive z-axis.
        
        var render = function () {  
            
            for(var i = 0; i < barsLeft.length; i++)
            {
                if(barsLeft[i].position.z <= 50)
                {
                    barsLeft[i].position.z += 1;
                }
                else
                {
                    barsLeft[i].position.z = -200;
                }

                if(barsLeft[i].scale.y <= 0)
                {
                    var rand = Math.floor((Math.random() * 1.2) + 0.1);
                    scaleY(barsLeft[i], rand);
                }
                else
                {
                    scaleY(barsLeft[i], barsLeft[i].scale.y-0.02);
                }
            }
            
            for(var i = 0; i < barsRight.length; i++)
            {
                if(barsRight[i].position.z <= 50)
                {
                    barsRight[i].position.z += 1;
                }
                else
                {
                    barsRight[i].position.z = -200;
                }

                if(barsRight[i].scale.y <= 0)
                {
                    var rand = Math.floor((Math.random() * 1.2) + 0.1);
                    scaleY(barsRight[i], rand);
                }
                else
                {
                    scaleY(barsRight[i], barsRight[i].scale.y-0.02);
                }
            }
            
            renderer.render(scene, camera); // Each time we change the position of the cube object, we must re-render it.
            requestAnimationFrame(render); // Call the render() function up to 60 times per second (i.e., up to 60 animation frames per second).
        };

        render(); // Start the rendering of the animation frames.
        
        function scaleY ( mesh, scale ) {
            mesh.scale.y = scale ;
            if( ! mesh.geometry.boundingBox ) mesh.geometry.computeBoundingBox();
            var height = mesh.geometry.boundingBox.max.y - mesh.geometry.boundingBox.min.y;
            //height is here the native height of the geometry
            //that does not change with scaling. 
            //So we need to multiply with scale again
            mesh.position.y = height * scale / 2 - 20;
        }
    </script>
</body>
</html>